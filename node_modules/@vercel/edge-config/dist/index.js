// src/index.ts
import { readFile } from "@vercel/edge-config-fs";

// package.json
var name = "@vercel/edge-config";
var version = "0.4.1";

// src/utils/index.ts
var ERRORS = {
  UNEXPECTED: "@vercel/edge-config: Unexpected error",
  UNAUTHORIZED: "@vercel/edge-config: Unauthorized",
  NETWORK: "@vercel/edge-config: Network error",
  EDGE_CONFIG_NOT_FOUND: "@vercel/edge-config: Edge Config not found"
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function pick(obj, keys) {
  const ret = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}
function assertIsKey(key) {
  if (typeof key !== "string") {
    throw new Error("@vercel/edge-config: Expected key to be a string");
  }
}
function assertIsKeys(keys) {
  if (!Array.isArray(keys) || keys.some((key) => typeof key !== "string")) {
    throw new Error(
      "@vercel/edge-config: Expected keys to be an array of string"
    );
  }
}
function clone(value) {
  if (typeof structuredClone === "function")
    return structuredClone(value);
  if (value === void 0)
    return value;
  return JSON.parse(JSON.stringify(value));
}
function parseVercelConnectionString(text) {
  try {
    const url = new URL(text);
    if (url.host !== "edge-config.vercel.com")
      return null;
    if (url.protocol !== "https:")
      return null;
    if (!url.pathname.startsWith("/ecfg"))
      return null;
    const id = url.pathname.split("/")[1];
    if (!id)
      return null;
    const token = url.searchParams.get("token");
    if (!token || token === "")
      return null;
    return {
      type: "vercel",
      baseUrl: `https://edge-config.vercel.com/${id}`,
      id,
      version: "1",
      token
    };
  } catch {
    return null;
  }
}
function parseExternalConnectionString(connectionString) {
  try {
    const url = new URL(connectionString);
    let id = url.searchParams.get("id");
    const token = url.searchParams.get("token");
    const version2 = url.searchParams.get("version") || "1";
    if (!id || url.pathname.startsWith("/ecfg_")) {
      id = url.pathname.split("/")[1] || null;
    }
    if (!id || !token)
      return null;
    url.search = "";
    return {
      type: "external",
      baseUrl: url.toString(),
      id,
      token,
      version: version2
    };
  } catch {
    return null;
  }
}
function parseConnectionString(connectionString) {
  const connection = parseVercelConnectionString(connectionString);
  if (connection)
    return connection;
  return parseExternalConnectionString(connectionString);
}
var isDynamicServerError = (error) => error instanceof Error && hasOwnProperty(error, "digest") && error.digest === "DYNAMIC_SERVER_USAGE";

// src/utils/fetch-with-cached-response.ts
function createResponse(cachedResponseEntry) {
  return new Response(cachedResponseEntry.response, {
    headers: {
      ...cachedResponseEntry.headers,
      Age: String(
        // age header may not be 0 when serving stale content, must be >= 1
        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3))
      )
    },
    status: cachedResponseEntry.status
  });
}
function createHandleStaleIfError(cachedResponseEntry, staleIfError) {
  return function handleStaleIfError(response) {
    switch (response.status) {
      case 500:
      case 502:
      case 503:
      case 504:
        return typeof staleIfError === "number" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;
      default:
        return response;
    }
  };
}
function createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {
  return function handleStaleIfError(reason) {
    if (typeof staleIfError === "number" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {
      return createResponse(cachedResponseEntry);
    }
    throw reason;
  };
}
var cache = /* @__PURE__ */ new Map();
function extractStaleIfError(cacheControlHeader) {
  if (!cacheControlHeader)
    return null;
  const matched = /stale-if-error=(?<staleIfError>\d+)/i.exec(
    cacheControlHeader
  );
  return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;
}
async function fetchWithCachedResponse(url, options = {}) {
  const { headers: customHeaders = new Headers(), ...customOptions } = options;
  const authHeader = customHeaders.get("Authorization");
  const cacheKey = `${url},${authHeader || ""}`;
  const cachedResponseEntry = cache.get(cacheKey);
  if (cachedResponseEntry) {
    const { etag: etag2, response: cachedResponse } = cachedResponseEntry;
    const headers = new Headers(customHeaders);
    headers.set("If-None-Match", etag2);
    const staleIfError = extractStaleIfError(headers.get("Cache-Control"));
    const res2 = await fetch(url, {
      ...customOptions,
      headers
    }).then(
      createHandleStaleIfError(cachedResponseEntry, staleIfError),
      createHandleStaleIfErrorException(cachedResponseEntry, staleIfError)
    );
    if (res2.status === 304) {
      res2.cachedResponseBody = JSON.parse(cachedResponse);
      return res2;
    }
    const newETag = res2.headers.get("ETag");
    if (res2.ok && newETag)
      cache.set(cacheKey, {
        etag: newETag,
        response: await res2.clone().text(),
        headers: Object.fromEntries(res2.headers.entries()),
        status: res2.status,
        time: Date.now()
      });
    return res2;
  }
  const res = await fetch(url, options);
  const etag = res.headers.get("ETag");
  if (res.ok && etag) {
    cache.set(cacheKey, {
      etag,
      response: await res.clone().text(),
      headers: Object.fromEntries(res.headers.entries()),
      status: res.status,
      time: Date.now()
    });
  }
  return res;
}

// src/index.ts
async function getFileSystemEdgeConfig(connection) {
  if (connection.type !== "vercel")
    return null;
  if (!process.env.AWS_LAMBDA_FUNCTION_NAME)
    return null;
  try {
    const content = await readFile(
      `/opt/edge-config/${connection.id}.json`,
      "utf-8"
    );
    return JSON.parse(content);
  } catch {
    return null;
  }
}
async function consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res) {
  if (typeof EdgeRuntime !== "undefined")
    return;
  await res.arrayBuffer();
}
function createClient(connectionString, options = {
  staleIfError: 604800
  /* one week */
}) {
  if (!connectionString)
    throw new Error("@vercel/edge-config: No connection string provided");
  const connection = parseConnectionString(connectionString);
  if (!connection)
    throw new Error("@vercel/edge-config: Invalid connection string provided");
  const baseUrl = connection.baseUrl;
  const version2 = connection.version;
  const headers = {
    Authorization: `Bearer ${connection.token}`
  };
  if (typeof process !== "undefined" && process.env.VERCEL_ENV)
    headers["x-edge-config-vercel-env"] = process.env.VERCEL_ENV;
  if (typeof name === "string" && typeof version === "string")
    headers["x-edge-config-sdk"] = `${name}@${version}`;
  if (typeof options.staleIfError === "number" && options.staleIfError > 0)
    headers["cache-control"] = `stale-if-error=${options.staleIfError}`;
  return {
    connection,
    async get(key) {
      const localEdgeConfig = await getFileSystemEdgeConfig(connection);
      if (localEdgeConfig) {
        assertIsKey(key);
        return Promise.resolve(clone(localEdgeConfig.items[key]));
      }
      assertIsKey(key);
      return fetchWithCachedResponse(
        `${baseUrl}/item/${key}?version=${version2}`,
        {
          headers: new Headers(headers),
          cache: "no-store"
        }
      ).then(
        async (res) => {
          if (res.ok)
            return res.json();
          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);
          if (res.status === 401)
            throw new Error(ERRORS.UNAUTHORIZED);
          if (res.status === 404) {
            if (res.headers.has("x-edge-config-digest"))
              return void 0;
            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
          }
          if (res.cachedResponseBody !== void 0)
            return res.cachedResponseBody;
          throw new Error(ERRORS.UNEXPECTED);
        },
        (error) => {
          if (isDynamicServerError(error))
            throw error;
          throw new Error(ERRORS.NETWORK);
        }
      );
    },
    async has(key) {
      const localEdgeConfig = await getFileSystemEdgeConfig(connection);
      if (localEdgeConfig) {
        assertIsKey(key);
        return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));
      }
      assertIsKey(key);
      return fetch(`${baseUrl}/item/${key}?version=${version2}`, {
        method: "HEAD",
        headers: new Headers(headers),
        cache: "no-store"
      }).then(
        (res) => {
          if (res.status === 401)
            throw new Error(ERRORS.UNAUTHORIZED);
          if (res.status === 404) {
            if (res.headers.has("x-edge-config-digest"))
              return false;
            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
          }
          if (res.ok)
            return true;
          throw new Error(ERRORS.UNEXPECTED);
        },
        (error) => {
          if (isDynamicServerError(error))
            throw error;
          throw new Error(ERRORS.NETWORK);
        }
      );
    },
    async getAll(keys) {
      const localEdgeConfig = await getFileSystemEdgeConfig(connection);
      if (localEdgeConfig) {
        if (keys === void 0) {
          return Promise.resolve(clone(localEdgeConfig.items));
        }
        assertIsKeys(keys);
        return Promise.resolve(clone(pick(localEdgeConfig.items, keys)));
      }
      if (Array.isArray(keys))
        assertIsKeys(keys);
      const search = Array.isArray(keys) ? new URLSearchParams(
        keys.map((key) => ["key", key])
      ).toString() : null;
      if (search === "")
        return Promise.resolve({});
      return fetchWithCachedResponse(
        `${baseUrl}/items?version=${version2}${search === null ? "" : `&${search}`}`,
        {
          headers: new Headers(headers),
          cache: "no-store"
        }
      ).then(
        async (res) => {
          if (res.ok)
            return res.json();
          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);
          if (res.status === 401)
            throw new Error(ERRORS.UNAUTHORIZED);
          if (res.status === 404)
            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);
          if (res.cachedResponseBody !== void 0)
            return res.cachedResponseBody;
          throw new Error(ERRORS.UNEXPECTED);
        },
        (error) => {
          if (isDynamicServerError(error))
            throw error;
          throw new Error(ERRORS.NETWORK);
        }
      );
    },
    async digest() {
      const localEdgeConfig = await getFileSystemEdgeConfig(connection);
      if (localEdgeConfig) {
        return Promise.resolve(localEdgeConfig.digest);
      }
      return fetchWithCachedResponse(`${baseUrl}/digest?version=${version2}`, {
        headers: new Headers(headers),
        cache: "no-store"
      }).then(
        async (res) => {
          if (res.ok)
            return res.json();
          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);
          if (res.cachedResponseBody !== void 0)
            return res.cachedResponseBody;
          throw new Error(ERRORS.UNEXPECTED);
        },
        (error) => {
          if (isDynamicServerError(error))
            throw error;
          throw new Error(ERRORS.NETWORK);
        }
      );
    }
  };
}
var defaultEdgeConfigClient;
function init() {
  if (!defaultEdgeConfigClient) {
    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);
  }
}
var get = (...args) => {
  init();
  return defaultEdgeConfigClient.get(...args);
};
var getAll = (...args) => {
  init();
  return defaultEdgeConfigClient.getAll(...args);
};
var has = (...args) => {
  init();
  return defaultEdgeConfigClient.has(...args);
};
var digest = (...args) => {
  init();
  return defaultEdgeConfigClient.digest(...args);
};
export {
  createClient,
  digest,
  get,
  getAll,
  has,
  parseConnectionString
};
//# sourceMappingURL=index.js.map
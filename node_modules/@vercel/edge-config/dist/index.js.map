{"version":3,"sources":["../src/index.ts","../package.json","../src/utils/index.ts","../src/utils/fetch-with-cached-response.ts"],"sourcesContent":["import { readFile } from '@vercel/edge-config-fs';\nimport { name as sdkName, version as sdkVersion } from '../package.json';\nimport {\n  assertIsKey,\n  assertIsKeys,\n  clone,\n  ERRORS,\n  hasOwnProperty,\n  isDynamicServerError,\n  parseConnectionString,\n  pick,\n} from './utils';\nimport type {\n  Connection,\n  EdgeConfigClient,\n  EdgeConfigItems,\n  EdgeConfigValue,\n  EmbeddedEdgeConfig,\n} from './types';\nimport { fetchWithCachedResponse } from './utils/fetch-with-cached-response';\n\nexport {\n  parseConnectionString,\n  type EdgeConfigClient,\n  type EdgeConfigItems,\n  type EdgeConfigValue,\n  type EmbeddedEdgeConfig,\n};\n\n/**\n * Reads an Edge Config from the local file system.\n * This is used at runtime on serverless functions.\n */\nasync function getFileSystemEdgeConfig(\n  connection: Connection\n): Promise<EmbeddedEdgeConfig | null> {\n  // can't optimize non-vercel hosted edge configs\n  if (connection.type !== 'vercel') return null;\n  // can't use fs optimizations outside of lambda\n  if (!process.env.AWS_LAMBDA_FUNCTION_NAME) return null;\n\n  try {\n    const content = await readFile(\n      `/opt/edge-config/${connection.id}.json`,\n      'utf-8'\n    );\n    return JSON.parse(content) as EmbeddedEdgeConfig;\n  } catch {\n    return null;\n  }\n}\n\nasync function consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(\n  res: Response\n): Promise<void> {\n  if (typeof EdgeRuntime !== 'undefined') return;\n\n  // Read body to avoid memory leaks in nodejs\n  // see https://github.com/nodejs/undici/blob/v5.21.2/README.md#garbage-collection\n  // see https://github.com/node-fetch/node-fetch/issues/83\n  await res.arrayBuffer();\n}\n\ninterface EdgeConfigClientOptions {\n  /**\n   * The stale-if-error response directive indicates that the cache can reuse a\n   * stale response when an upstream server generates an error, or when the error\n   * is generated locally - for example due to a connection error.\n   *\n   * Any response with a status code of 500, 502, 503, or 504 is considered an error.\n   *\n   * Pass a negative number, 0, or false to turn disable stale-if-error semantics.\n   *\n   * The time is supplied in seconds. Defaults to one week (`604800`).\n   */\n  staleIfError: number | false;\n}\n\n/**\n * Create an Edge Config client.\n *\n * The client has multiple methods which allow you to read the Edge Config.\n *\n * If you need to programmatically write to an Edge Config, check out the [Update your Edge Config items](https://vercel.com/docs/storage/edge-config/vercel-api#update-your-edge-config-items) section.\n *\n * @param connectionString - A connection string. Usually you'd pass in `process.env.EDGE_CONFIG` here, which contains a connection string.\n * @returns An Edge Config Client instance\n */\nexport function createClient(\n  connectionString: string | undefined,\n  options: EdgeConfigClientOptions = { staleIfError: 604800 /* one week */ }\n): EdgeConfigClient {\n  if (!connectionString)\n    throw new Error('@vercel/edge-config: No connection string provided');\n\n  const connection = parseConnectionString(connectionString);\n\n  if (!connection)\n    throw new Error('@vercel/edge-config: Invalid connection string provided');\n\n  const baseUrl = connection.baseUrl;\n  const version = connection.version; // version of the edge config read access api we talk to\n  const headers: Record<string, string> = {\n    Authorization: `Bearer ${connection.token}`,\n  };\n\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain -- [@vercel/style-guide@5 migration]\n  if (typeof process !== 'undefined' && process.env.VERCEL_ENV)\n    headers['x-edge-config-vercel-env'] = process.env.VERCEL_ENV;\n\n  if (typeof sdkName === 'string' && typeof sdkVersion === 'string')\n    headers['x-edge-config-sdk'] = `${sdkName}@${sdkVersion}`;\n\n  if (typeof options.staleIfError === 'number' && options.staleIfError > 0)\n    headers['cache-control'] = `stale-if-error=${options.staleIfError}`;\n\n  return {\n    connection,\n    async get<T = EdgeConfigValue>(key: string): Promise<T | undefined> {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n      if (localEdgeConfig) {\n        assertIsKey(key);\n\n        // We need to return a clone of the value so users can't modify\n        // our original value, and so the reference changes.\n        //\n        // This makes it consistent with the real API.\n        return Promise.resolve(clone(localEdgeConfig.items[key]) as T);\n      }\n\n      assertIsKey(key);\n      return fetchWithCachedResponse(\n        `${baseUrl}/item/${key}?version=${version}`,\n        {\n          headers: new Headers(headers),\n          cache: 'no-store',\n        }\n      ).then<T | undefined, undefined>(\n        async (res) => {\n          if (res.ok) return res.json();\n          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n\n          if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n          if (res.status === 404) {\n            // if the x-edge-config-digest header is present, it means\n            // the edge config exists, but the item does not\n            if (res.headers.has('x-edge-config-digest')) return undefined;\n            // if the x-edge-config-digest header is not present, it means\n            // the edge config itself does not exist\n            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n          }\n          if (res.cachedResponseBody !== undefined)\n            return res.cachedResponseBody as T;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error)) throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n    async has(key): Promise<boolean> {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n      if (localEdgeConfig) {\n        assertIsKey(key);\n        return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n      }\n\n      assertIsKey(key);\n      // this is a HEAD request anyhow, no need for fetchWithCachedResponse\n      return fetch(`${baseUrl}/item/${key}?version=${version}`, {\n        method: 'HEAD',\n        headers: new Headers(headers),\n        cache: 'no-store',\n      }).then(\n        (res) => {\n          if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n          if (res.status === 404) {\n            // if the x-edge-config-digest header is present, it means\n            // the edge config exists, but the item does not\n            if (res.headers.has('x-edge-config-digest')) return false;\n            // if the x-edge-config-digest header is not present, it means\n            // the edge config itself does not exist\n            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n          }\n          if (res.ok) return true;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error)) throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n    async getAll<T = EdgeConfigItems>(keys?: (keyof T)[]): Promise<T> {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n\n      if (localEdgeConfig) {\n        if (keys === undefined) {\n          return Promise.resolve(clone(localEdgeConfig.items) as T);\n        }\n\n        assertIsKeys(keys);\n        return Promise.resolve(clone(pick(localEdgeConfig.items, keys)) as T);\n      }\n\n      if (Array.isArray(keys)) assertIsKeys(keys);\n\n      const search = Array.isArray(keys)\n        ? new URLSearchParams(\n            keys.map((key) => ['key', key] as [string, string])\n          ).toString()\n        : null;\n\n      // empty search keys array was given,\n      // so skip the request and return an empty object\n      if (search === '') return Promise.resolve({} as T);\n\n      return fetchWithCachedResponse(\n        `${baseUrl}/items?version=${version}${\n          search === null ? '' : `&${search}`\n        }`,\n        {\n          headers: new Headers(headers),\n          cache: 'no-store',\n        }\n      ).then<T>(\n        async (res) => {\n          if (res.ok) return res.json();\n          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n\n          if (res.status === 401) throw new Error(ERRORS.UNAUTHORIZED);\n          // the /items endpoint never returns 404, so if we get a 404\n          // it means the edge config itself did not exist\n          if (res.status === 404) throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n          if (res.cachedResponseBody !== undefined)\n            return res.cachedResponseBody as T;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error)) throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n    async digest(): Promise<string> {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n\n      if (localEdgeConfig) {\n        return Promise.resolve(localEdgeConfig.digest);\n      }\n\n      return fetchWithCachedResponse(`${baseUrl}/digest?version=${version}`, {\n        headers: new Headers(headers),\n        cache: 'no-store',\n      }).then(\n        async (res) => {\n          if (res.ok) return res.json() as Promise<string>;\n          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n\n          if (res.cachedResponseBody !== undefined)\n            return res.cachedResponseBody as string;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error)) throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n  };\n}\n\nlet defaultEdgeConfigClient: EdgeConfigClient;\n\n// lazy init fn so the default edge config does not throw in case\n// process.env.EDGE_CONFIG is not defined and its methods are never used.\nfunction init(): void {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- [@vercel/style-guide@5 migration]\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\n\n/**\n * Reads a single item from the default Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).get()`.\n *\n * @see {@link EdgeConfigClient.get}\n * @param key - the key to read\n * @returns the value stored under the given key, or undefined\n */\nexport const get: EdgeConfigClient['get'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\n\n/**\n * Reads multiple or all values.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).getAll()`.\n *\n * @see {@link EdgeConfigClient.getAll}\n * @param keys - the keys to read\n * @returns the value stored under the given key, or undefined\n */\nexport const getAll: EdgeConfigClient['getAll'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\n\n/**\n * Check if a given key exists in the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).has()`.\n *\n * @see {@link EdgeConfigClient.has}\n * @param key - the key to check\n * @returns true if the given key exists in the Edge Config.\n */\nexport const has: EdgeConfigClient['has'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\n\n/**\n * Get the digest of the Edge Config.\n *\n * This is a convenience method which reads the default Edge Config.\n * It is conceptually similar to `createClient(process.env.EDGE_CONFIG).digest()`.\n *\n * @see {@link EdgeConfigClient.digest}\n * @returns The digest of the Edge Config.\n */\nexport const digest: EdgeConfigClient['digest'] = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\n","{\n  \"name\": \"@vercel/edge-config\",\n  \"version\": \"0.4.1\",\n  \"description\": \"Ultra-low latency data at the edge\",\n  \"homepage\": \"https://vercel.com\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/vercel/storage.git\",\n    \"directory\": \"packages/edge-config\"\n  },\n  \"license\": \"Apache-2.0\",\n  \"sideEffects\": false,\n  \"type\": \"module\",\n  \"exports\": {\n    \"import\": \"./dist/index.js\",\n    \"require\": \"./dist/index.cjs\"\n  },\n  \"main\": \"./dist/index.cjs\",\n  \"module\": \"./dist/index.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch --clean=false\",\n    \"lint\": \"eslint --max-warnings=0 .\",\n    \"prepublishOnly\": \"pnpm run build\",\n    \"prettier-check\": \"prettier --check .\",\n    \"publint\": \"npx publint\",\n    \"test\": \"pnpm run test:node && pnpm run test:edge && pnpm run test:common\",\n    \"test:common\": \"jest --env @edge-runtime/jest-environment .common.test.ts && jest --env node .common.test.ts\",\n    \"test:edge\": \"jest --env @edge-runtime/jest-environment .edge.test.ts\",\n    \"test:node\": \"jest --env node .node.test.ts\",\n    \"type-check\": \"tsc --noEmit\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"setupFiles\": [\n      \"<rootDir>/jest/setup.js\"\n    ],\n    \"testEnvironment\": \"node\"\n  },\n  \"dependencies\": {\n    \"@vercel/edge-config-fs\": \"workspace:*\"\n  },\n  \"devDependencies\": {\n    \"@changesets/cli\": \"2.26.2\",\n    \"@edge-runtime/jest-environment\": \"2.3.3\",\n    \"@edge-runtime/types\": \"2.2.3\",\n    \"@types/jest\": \"29.5.5\",\n    \"@types/node\": \"18.17.17\",\n    \"eslint\": \"8.49.0\",\n    \"eslint-config-custom\": \"workspace:*\",\n    \"jest\": \"29.7.0\",\n    \"jest-fetch-mock\": \"3.0.3\",\n    \"node-domexception\": \"2.0.1\",\n    \"prettier\": \"2.8.8\",\n    \"ts-jest\": \"29.1.1\",\n    \"tsconfig\": \"workspace:*\",\n    \"tsup\": \"7.2.0\",\n    \"typescript\": \"5.2.2\"\n  },\n  \"engines\": {\n    \"node\": \">=14.6\"\n  }\n}\n","import type { Connection } from '../types';\n\nexport const ERRORS = {\n  UNEXPECTED: '@vercel/edge-config: Unexpected error',\n  UNAUTHORIZED: '@vercel/edge-config: Unauthorized',\n  NETWORK: '@vercel/edge-config: Network error',\n  EDGE_CONFIG_NOT_FOUND: '@vercel/edge-config: Edge Config not found',\n};\n\n/**\n * Checks if an object has a property\n */\nexport function hasOwnProperty<X, Y extends PropertyKey>(\n  obj: X,\n  prop: Y\n): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nexport function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const ret: Partial<T> = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret as Pick<T, K>;\n}\n\nexport function assertIsKey(key: unknown): asserts key is string {\n  if (typeof key !== 'string') {\n    throw new Error('@vercel/edge-config: Expected key to be a string');\n  }\n}\n\nexport function assertIsKeys(keys: unknown): asserts keys is string[] {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== 'string')) {\n    throw new Error(\n      '@vercel/edge-config: Expected keys to be an array of string'\n    );\n  }\n}\n\n/**\n * Creates a deep clone of an object.\n */\nexport function clone<T>(value: T): T {\n  // only available since node v17.0.0\n  if (typeof structuredClone === 'function') return structuredClone<T>(value);\n\n  // poor man's polyfill for structuredClone\n  if (value === undefined) return value;\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n\n/**\n * Parses internal edge config connection strings\n *\n * Internal edge config connection strings are those which are native to Vercel.\n *\n * Internal Edge Config Connection Strings look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n */\nfunction parseVercelConnectionString(text: string): Connection | null {\n  try {\n    const url = new URL(text);\n    if (url.host !== 'edge-config.vercel.com') return null;\n    if (url.protocol !== 'https:') return null;\n    if (!url.pathname.startsWith('/ecfg')) return null;\n\n    const id = url.pathname.split('/')[1];\n    if (!id) return null;\n\n    const token = url.searchParams.get('token');\n    if (!token || token === '') return null;\n\n    return {\n      type: 'vercel',\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: '1',\n      token,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parses info contained in connection strings.\n *\n * This works with the vercel-provided connection strings, but it also\n * works with custom connection strings.\n *\n * The reason we support custom connection strings is that it makes testing\n * edge config really straightforward. Users can provide  connection strings\n * pointing to their own servers and then either have a custom server\n * return the desired values or even intercept requests with something like\n * msw.\n *\n * To allow interception we need a custom connection string as the\n * edge-config.vercel.com connection string might not always go over\n * the network, so msw would not have a chance to intercept.\n */\n/**\n * Parses external edge config connection strings\n *\n * External edge config connection strings are those which are foreign to Vercel.\n *\n * External Edge Config Connection Strings look like this:\n * - https://example.com/?id=<edgeConfigId>&token=<token>\n * - https://example.com/<edgeConfigId>?token=<token>\n */\nfunction parseExternalConnectionString(\n  connectionString: string\n): Connection | null {\n  try {\n    const url = new URL(connectionString);\n\n    let id: string | null = url.searchParams.get('id');\n    const token = url.searchParams.get('token');\n    const version = url.searchParams.get('version') || '1';\n\n    // try to determine id based on pathname if it wasn't provided explicitly\n    if (!id || url.pathname.startsWith('/ecfg_')) {\n      id = url.pathname.split('/')[1] || null;\n    }\n\n    if (!id || !token) return null;\n\n    // remove all search params for use as baseURL\n    url.search = '';\n\n    // try to parse as external connection string\n    return {\n      type: 'external',\n      baseUrl: url.toString(),\n      id,\n      token,\n      version,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Parse the edgeConfigId and token from an Edge Config Connection String.\n *\n * Edge Config Connection Strings usually look like this:\n * https://edge-config.vercel.com/<edgeConfigId>?token=<token>\n *\n * @param text - A potential Edge Config Connection String\n * @returns The connection parsed from the given Connection String or null.\n */\nexport function parseConnectionString(\n  connectionString: string\n): Connection | null {\n  const connection = parseVercelConnectionString(connectionString);\n  if (connection) return connection;\n  return parseExternalConnectionString(connectionString);\n}\n\n/**\n * Works around an issue in Next.js.\n *\n * Next.js problematically expects to be able to throw DynamicServerError and\n * for it to be passed all the way upwards, but we are catching all errors and\n * mapping them to a generic NetworkError.\n *\n * We do this catch-all to prevent leaky abstractions.\n * Otherwise we might leak our implementation details through errors.\n *\n * But this breaks Next.js. So we need to make an exception for it until Next.js\n * no longer expects this behavior.\n *\n * Without this fix, Next.js would fail builds of in which edge config is read\n * from async page components.\n *\n * https://github.com/vercel/storage/issues/119\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- [@vercel/style-guide@5 migration]\nexport const isDynamicServerError = (error: any): boolean =>\n  error instanceof Error &&\n  hasOwnProperty(error, 'digest') &&\n  error.digest === 'DYNAMIC_SERVER_USAGE';\n","interface CachedResponseEntry {\n  etag: string;\n  response: string;\n  headers: Record<string, string>;\n  status: number;\n  time: number;\n}\n\ntype FetchOptions = Omit<RequestInit, 'headers'> & { headers?: Headers };\n\ninterface ResponseWithCachedResponse extends Response {\n  cachedResponseBody?: unknown;\n}\n\n/**\n * Creates a new response based on a cache entry\n */\nfunction createResponse(\n  cachedResponseEntry: CachedResponseEntry\n): ResponseWithCachedResponse {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1000))\n      ),\n    },\n    status: cachedResponseEntry.status,\n  });\n}\n\n/**\n * Used for bad responses like 500s\n */\nfunction createHandleStaleIfError(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null\n) {\n  return function handleStaleIfError(\n    response: ResponseWithCachedResponse\n  ): ResponseWithCachedResponse {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === 'number' &&\n          cachedResponseEntry.time < Date.now() + staleIfError * 1000\n          ? createResponse(cachedResponseEntry)\n          : response;\n      default:\n        return response;\n    }\n  };\n}\n\n/**\n * Used on network errors which end up throwing\n */\nfunction createHandleStaleIfErrorException(\n  cachedResponseEntry: CachedResponseEntry,\n  staleIfError: number | null\n) {\n  return function handleStaleIfError(\n    reason: unknown\n  ): ResponseWithCachedResponse {\n    if (\n      typeof staleIfError === 'number' &&\n      cachedResponseEntry.time < Date.now() + staleIfError * 1000\n    ) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\n\n/**\n * A cache of request urls & auth headers and the resulting responses.\n *\n * This cache does not use Response instances as the cache value as reusing\n * responses across requests leads to issues in Cloudflare Workers.\n */\nexport const cache = new Map<string, CachedResponseEntry>();\n\nfunction extractStaleIfError(cacheControlHeader: string | null): number | null {\n  if (!cacheControlHeader) return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader\n  );\n  return matched?.groups ? Number(matched.groups.staleIfError) : null;\n}\n\n/**\n * This is similar to fetch, but it also implements ETag semantics, and\n * it implmenets stale-if-error semantics.\n */\nexport async function fetchWithCachedResponse(\n  url: string,\n  options: FetchOptions = {}\n): Promise<ResponseWithCachedResponse> {\n  const { headers: customHeaders = new Headers(), ...customOptions } = options;\n  const authHeader = customHeaders.get('Authorization');\n  const cacheKey = `${url},${authHeader || ''}`;\n\n  const cachedResponseEntry = cache.get(cacheKey);\n\n  if (cachedResponseEntry) {\n    const { etag, response: cachedResponse } = cachedResponseEntry;\n    const headers = new Headers(customHeaders);\n    headers.set('If-None-Match', etag);\n\n    const staleIfError = extractStaleIfError(headers.get('Cache-Control'));\n\n    const res: ResponseWithCachedResponse = await fetch(url, {\n      ...customOptions,\n      headers,\n    }).then(\n      createHandleStaleIfError(cachedResponseEntry, staleIfError),\n      createHandleStaleIfErrorException(cachedResponseEntry, staleIfError)\n    );\n\n    if (res.status === 304) {\n      res.cachedResponseBody = JSON.parse(cachedResponse);\n      return res;\n    }\n\n    const newETag = res.headers.get('ETag');\n    if (res.ok && newETag)\n      cache.set(cacheKey, {\n        etag: newETag,\n        response: await res.clone().text(),\n        headers: Object.fromEntries(res.headers.entries()),\n        status: res.status,\n        time: Date.now(),\n      });\n    return res;\n  }\n\n  const res = await fetch(url, options);\n  const etag = res.headers.get('ETag');\n  if (res.ok && etag) {\n    cache.set(cacheKey, {\n      etag,\n      response: await res.clone().text(),\n      headers: Object.fromEntries(res.headers.entries()),\n      status: res.status,\n      time: Date.now(),\n    });\n  }\n\n  return res;\n}\n"],"mappings":"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","names":["version","etag","res","version"]}